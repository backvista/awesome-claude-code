#!/usr/bin/env bash
#
# ACC - Awesome Claude Code CLI
# Принудительное обновление компонентов Claude с поддержкой резервного копирования
#

set -euo pipefail

# Цвета
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly CYAN='\033[0;36m'
readonly RESET='\033[0m'

# Конфигурация
readonly PACKAGE_NAME="backvista/awesome-claude-code"
readonly COMPONENTS=("commands" "agents" "skills")

# Глобальные переменные
CREATE_BACKUP=true
COMPONENT_FILTER=""
COMMAND=""

print_usage() {
    cat << EOF
${CYAN}ACC - Awesome Claude Code CLI${RESET}

Использование: acc <команда> [опции]

Команды:
  upgrade     Принудительное обновление компонентов Claude из vendor

Опции:
  --no-backup           Пропустить создание резервной копии
  --component=<name>    Обновить только указанный компонент (commands|agents|skills)
  -h, --help            Показать эту справку

Примеры:
  acc upgrade                          # Полное обновление с резервной копией
  acc upgrade --no-backup              # Обновление без резервной копии
  acc upgrade --component=commands     # Обновить только команды

EOF
}

print_error() {
    echo -e "${RED}Ошибка:${RESET} $1" >&2
}

print_success() {
    echo -e "${GREEN}✓${RESET} $1"
}

print_info() {
    echo -e "${CYAN}→${RESET} $1"
}

print_warning() {
    echo -e "${YELLOW}!${RESET} $1"
}

find_project_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/composer.json" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

find_vendor_source() {
    local project_root="$1"
    local vendor_dir="${project_root}/vendor"
    local source="${vendor_dir}/${PACKAGE_NAME}/.claude"

    if [[ -d "$source" ]]; then
        echo "$source"
        return 0
    fi
    return 1
}

create_backup() {
    local target_dir="$1"
    local project_root="$2"

    if [[ ! -d "$target_dir" ]]; then
        print_info "Нет существующей директории .claude для резервного копирования"
        return 0
    fi

    local timestamp
    timestamp=$(date +"%Y-%m-%d-%H%M%S")
    local backup_dir="${project_root}/.claude.backup.${timestamp}"

    print_info "Создание резервной копии: ${backup_dir}"
    cp -r "$target_dir" "$backup_dir"
    print_success "Резервная копия создана"
}

remove_components() {
    local target_dir="$1"
    local components=("${@:2}")

    for component in "${components[@]}"; do
        local component_path="${target_dir}/${component}"
        if [[ -d "$component_path" ]]; then
            print_info "Удаление: .claude/${component}/"
            rm -rf "$component_path"
        fi
    done
}

copy_components() {
    local source_dir="$1"
    local target_dir="$2"
    local components=("${@:3}")

    mkdir -p "$target_dir"

    for component in "${components[@]}"; do
        local source_path="${source_dir}/${component}"
        local target_path="${target_dir}/${component}"

        if [[ -d "$source_path" ]]; then
            print_info "Копирование: .claude/${component}/"
            cp -r "$source_path" "$target_path"

            local count
            count=$(find "$target_path" -type f -name "*.md" | wc -l | tr -d ' ')
            print_success "Скопировано ${count} файлов в .claude/${component}/"
        else
            print_warning "Источник не найден: ${source_path}"
        fi
    done
}

cmd_upgrade() {
    echo ""
    echo -e "${CYAN}ACC Обновление${RESET}"
    echo ""

    # Поиск корня проекта
    local project_root
    if ! project_root=$(find_project_root); then
        print_error "Не найден composer.json в текущей или родительских директориях"
        exit 1
    fi

    # Поиск источника в vendor
    local source_dir
    if ! source_dir=$(find_vendor_source "$project_root"); then
        print_error "Пакет не найден в vendor. Сначала выполните 'composer require ${PACKAGE_NAME}'."
        exit 1
    fi

    local target_dir="${project_root}/.claude"

    print_info "Корень проекта: ${project_root}"
    print_info "Источник: ${source_dir}"
    print_info "Назначение: ${target_dir}"
    echo ""

    # Определение компонентов для обновления
    local components_to_upgrade=()
    if [[ -n "$COMPONENT_FILTER" ]]; then
        # Валидация имени компонента
        local valid=false
        for c in "${COMPONENTS[@]}"; do
            if [[ "$c" == "$COMPONENT_FILTER" ]]; then
                valid=true
                break
            fi
        done

        if [[ "$valid" == false ]]; then
            print_error "Некорректный компонент: ${COMPONENT_FILTER}"
            print_error "Допустимые компоненты: ${COMPONENTS[*]}"
            exit 1
        fi

        components_to_upgrade=("$COMPONENT_FILTER")
        print_info "Обновление компонента: ${COMPONENT_FILTER}"
    else
        components_to_upgrade=("${COMPONENTS[@]}")
        print_info "Обновление всех компонентов: ${COMPONENTS[*]}"
    fi
    echo ""

    # Создание резервной копии при необходимости
    if [[ "$CREATE_BACKUP" == true ]]; then
        create_backup "$target_dir" "$project_root"
        echo ""
    else
        print_warning "Пропуск резервного копирования (--no-backup)"
        echo ""
    fi

    # Удаление старых компонентов
    remove_components "$target_dir" "${components_to_upgrade[@]}"
    echo ""

    # Копирование новых компонентов
    copy_components "$source_dir" "$target_dir" "${components_to_upgrade[@]}"
    echo ""

    print_success "Обновление завершено!"
    echo ""
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            upgrade)
                COMMAND="upgrade"
                shift
                ;;
            --no-backup)
                CREATE_BACKUP=false
                shift
                ;;
            --component=*)
                COMPONENT_FILTER="${1#*=}"
                shift
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            *)
                print_error "Неизвестная опция: $1"
                print_usage
                exit 1
                ;;
        esac
    done
}

main() {
    if [[ $# -eq 0 ]]; then
        print_usage
        exit 1
    fi

    parse_args "$@"

    if [[ -z "$COMMAND" ]]; then
        print_usage
        exit 1
    fi

    case "$COMMAND" in
        upgrade)
            cmd_upgrade
            ;;
        *)
            print_error "Неизвестная команда: $COMMAND"
            print_usage
            exit 1
            ;;
    esac
}

main "$@"
