---
name: acc-adr-template
description: Генерирует Architecture Decision Records (ADR) для PHP-проектов. Создаёт структурированную документацию решений с контекстом, решением и последствиями.
---

# Генератор шаблонов ADR

Генерирует Architecture Decision Records в стандартном формате.

## Формат ADR

```markdown
# ADR-{номер}: {Заголовок}

**Статус:** {Proposed | Accepted | Deprecated | Superseded}
**Дата:** {YYYY-MM-DD}
**Принимавшие решение:** {имена или роли}

## Контекст

{Какая проблема мотивирует это решение?}

## Решение

{Какое изменение мы предлагаем/делаем?}

## Последствия

### Положительные

{Что становится проще?}

### Отрицательные

{Что становится сложнее?}

### Риски

{Что может пойти не так?}

## Рассмотренные альтернативы

{Какие другие варианты были оценены?}

## Ссылки

{Ссылки на соответствующие ресурсы}
```

## Рекомендации по разделам

### Заголовок

```markdown
# ADR-001: Use Domain-Driven Design Architecture

Формат: "ADR-{NNN}: {Глагол} {Существительное/Концепция}"

Хорошо:
- Use Domain-Driven Design
- Implement CQRS Pattern
- Adopt PostgreSQL for Primary Storage
- Separate Read and Write Models

Плохо:
- DDD (слишком коротко)
- Architecture Decision (слишком расплывчато)
- We should use DDD (разговорный стиль)
```

### Значения статуса

```markdown
**Proposed** — обсуждается, ещё не принято
**Accepted** — решено и реализовано
**Deprecated** — больше не рекомендуется
**Superseded by ADR-XXX** — заменено более новым решением
```

### Раздел «Контекст»

```markdown
## Контекст

Опишите ситуацию, которая привела к этому решению:

- Какую проблему мы решаем?
- Какие силы действуют?
- Какие существуют ограничения?
- Каково текущее состояние?

Пример:
---
Система выросла до 50+ контроллеров с бизнес-логикой, разбросанной
по контроллерам, сервисам и репозиториям. Это приводит к:

- Дублированию кода между функциями
- Сложности тестирования бизнес-правил
- Неясному владению бизнес-логикой
- Сильной связанности с Symfony framework

Нам нужна чёткая структура для организации бизнес-логики.
```

### Раздел «Решение»

```markdown
## Решение

Сформулируйте решение чётко:

- Используйте активный залог
- Будьте конкретны о том, что меняется
- Включите ключевые детали реализации

Пример:
---
Мы примем Domain-Driven Design (DDD) со следующей структурой:

1. **Domain Layer** — содержит entities, value objects, domain events
   и интерфейсы репозиториев. Без зависимостей от фреймворка.

2. **Application Layer** — содержит use cases, которые оркестрируют доменные
   объекты. Определяет DTO для входа/выхода.

3. **Infrastructure Layer** — реализует интерфейсы репозиториев,
   интегрируется с БД, кешем и внешними сервисами.

4. **Presentation Layer** — обрабатывает HTTP-запросы/ответы используя
   ADR паттерн (Action-Domain-Responder).
```

### Раздел «Последствия»

```markdown
## Последствия

### Положительные

Перечислите полученные преимущества:
- Более чёткое разделение обязанностей
- Доменная логика независима от фреймворка
- Легче тестировать бизнес-правила
- Лучшая организация кода

### Отрицательные

Перечислите принятые недостатки:
- Больше файлов и директорий
- Кривая обучения для команды
- Начальные усилия по рефакторингу
- Больше шаблонного кода

### Риски

Перечислите потенциальные проблемы:
- Команда может чрезмерно усложнять простые функции
- Границы могут быть неверно определены изначально
- Рефакторинг существующего кода может внести баги
```

### Раздел «Альтернативы»

```markdown
## Рассмотренные альтернативы

### Альтернатива 1: {Название}

**Описание:** {Что это?}

**Плюсы:**
- {преимущество 1}
- {преимущество 2}

**Минусы:**
- {недостаток 1}
- {недостаток 2}

**Почему отклонена:** {причина}

### Альтернатива 2: {Название}

...
```

## Полный пример

```markdown
# ADR-003: Use PostgreSQL for Primary Database

**Статус:** Accepted
**Дата:** 2025-01-15
**Принимавшие решение:** Tech Lead, Backend Team

## Контекст

Нам нужно выбрать основную БД для новой системы управления заказами.
Требования включают:

- Поддержка сложных запросов по данным заказов
- JSONB-хранилище для гибких атрибутов продуктов
- Строгое соблюдение ACID для финансовых транзакций
- Хорошая производительность при масштабе 10K заказов/день
- Знакомство команды и поддержка экосистемы

Текущий технологический стек использует MySQL 5.7 для legacy-систем.

## Решение

Мы будем использовать PostgreSQL 16 как основную БД по следующим причинам:

1. **JSONB Support** — нативное JSON-хранилище с индексацией для атрибутов
   продуктов, которые варьируются по категориям

2. **Advanced Types** — UUID, массивы, enum как нативные типы уменьшают
   валидацию на уровне приложения

3. **Better Query Optimizer** — обрабатывает сложные JOIN по таблицам
   заказов, позиций и inventory более эффективно

4. **Extensibility** — PostGIS для будущих location-функций,
   full-text search без внешнего сервиса

Примечания к реализации:
- Использовать Doctrine ORM с PostgreSQL-специфичными типами
- Включить генерацию UUID на уровне БД
- Настроить connection pooling с PgBouncer

## Последствия

### Положительные

- Нативный JSONB устраняет необходимость в EAV-паттерне
- Лучшая производительность запросов для сложных отчётов
- Строгая типизация выявляет проблемы с данными раньше
- Современные возможности снижают сложность приложения

### Отрицательные

- Команде нужно обучение PostgreSQL (2-3 дня)
- Другой SQL-диалект от MySQL
- Стоимость хостинга немного выше
- Нет внутренней экспертизы DBA

### Риски

- Миграция с MySQL может выявить проблемы с данными
- Настройка производительности требует новой экспертизы
- Процедуры резервного копирования/восстановления нуждаются в обновлении

## Рассмотренные альтернативы

### MySQL 8.0

**Описание:** Обновление существующей MySQL инфраструктуры

**Плюсы:**
- Знакомство команды
- Существующий инструментарий и процедуры
- Меньшие усилия по миграции

**Минусы:**
- Поддержка JSON менее зрелая чем у PostgreSQL
- Отсутствие продвинутых типов
- Менее способный query optimizer

**Почему отклонена:** Долгосрочный технический долг превышает краткосрочное удобство

### MongoDB

**Описание:** Документная БД для гибкости

**Плюсы:**
- Гибкость схемы
- Нативный JSON
- Горизонтальное масштабирование

**Минусы:**
- Нет ACID для multi-document транзакций
- У команды нет опыта
- Сложные запросы труднее

**Почему отклонена:** Финансовые данные требуют строгих ACID-гарантий

## Ссылки

- [PostgreSQL vs MySQL Comparison](https://example.com/comparison)
- [PostgreSQL 16 Release Notes](https://www.postgresql.org/docs/16/release-16.html)
- Internal RFC: Database Selection Criteria
```

## Соглашение об именовании файлов

```
docs/adr/
├── 000-adr-template.md      # Файл-шаблон
├── 001-use-ddd.md           # Первое решение
├── 002-implement-cqrs.md    # Второе решение
├── 003-use-postgresql.md    # Третье решение
└── README.md                # Индекс всех ADR
```

## Шаблон индекса ADR

```markdown
# Architecture Decision Records

## Активные решения

| ADR | Дата | Заголовок | Статус |
|-----|------|-------|--------|
| [001](001-use-ddd.md) | 2025-01-10 | Use Domain-Driven Design | Accepted |
| [002](002-implement-cqrs.md) | 2025-01-12 | Implement CQRS Pattern | Accepted |
| [003](003-use-postgresql.md) | 2025-01-15 | Use PostgreSQL | Accepted |

## Устаревшие решения

| ADR | Дата | Заголовок | Заменено на |
|-----|------|-------|---------------|
| [000](000-monolith.md) | 2024-06-01 | Monolith Architecture | ADR-010 |
```

## Инструкции по генерации

При генерации ADR:

1. **Определить** следующий номер ADR из существующих файлов
2. **Уточнить** принимаемое решение
3. **Документировать** контекст тщательно
4. **Сформулировать** решение чётко с деталями
5. **Перечислить** последствия (положительные, отрицательные, риски)
6. **Включить** рассмотренные альтернативы
7. **Добавить** ссылки на соответствующие ресурсы
8. **Обновить** файл индекса ADR
